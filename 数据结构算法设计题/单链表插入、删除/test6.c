/*
 * 单链表基本操作示例程序
 * 功能：演示单链表的插入（头插、尾插、指定位置插入）和删除操作
 * 适合新手学习：包含详细注释，解释每一步的作用和原理
 */

// 标准输入输出库，用于printf等函数
#include <stdio.h>
// 标准库，用于malloc、free等内存管理函数
#include <stdlib.h>

// 定义元素类型为int，方便以后修改数据类型（比如改成char、double等）
typedef int ElemType;

// 定义单链表节点结构体
// 每个节点包含两部分：
// 1. data: 存储数据元素
// 2. next: 指向下一个节点的指针（链表的"链"就是这个指针）
typedef struct node
{
	ElemType data;	   // 节点的数据域，存储实际数据
	struct node *next; // 节点的指针域，指向下一个节点（如果没有下一个，则为NULL）
} Node;				   // 给struct node起一个别名Node，方便使用

/*
 * 功能：初始化链表
 * 说明：创建一个带头节点的空链表
 *      头节点不存储实际数据，只是作为链表的入口，方便操作
 * 返回值：返回指向头节点的指针
 */
Node *initList()
{
	// 动态分配内存空间，创建一个节点作为头节点
	// malloc(sizeof(Node))：分配一个Node大小的内存空间
	// (Node*)：将返回的void*指针强制转换为Node*类型
	Node *head = (Node *)malloc(sizeof(Node));

	// 头节点的数据域通常设为0或不使用（这里设为0）
	head->data = 0;

	// 头节点的指针域设为NULL，表示链表初始为空（没有数据节点）
	head->next = NULL;

	// 返回头节点指针
	return head;
}

/*
 * 功能：头插法插入节点
 * 参数：L - 链表头节点指针
 *      e - 要插入的数据元素
 * 说明：在链表的第一个位置（头节点之后）插入新节点
 *      新插入的节点会成为链表的第一个数据节点
 * 返回值：成功返回1，失败返回0
 */
int insertHead(Node *L, ElemType e)
{
	// 为要插入的新节点分配内存空间
	Node *p = (Node *)malloc(sizeof(Node));

	// 将数据存入新节点的数据域
	p->data = e;

	// 关键步骤1：让新节点的next指向原来头节点的next
	// 这样新节点就"接上"了原来链表的第一个节点
	p->next = L->next;

	// 关键步骤2：让头节点的next指向新节点
	// 这样新节点就成为了链表的第一个数据节点
	L->next = p;

	return 1; // 插入成功
}

/*
 * 功能：遍历链表并打印所有节点的数据
 * 参数：L - 链表头节点指针
 * 说明：从头节点的下一个节点开始，依次访问每个节点，直到遇到NULL
 */
void listNode(Node *L)
{
	// 从第一个数据节点开始遍历（跳过头节点）
	Node *p = L->next;

	// 当p不为NULL时，说明还有节点未遍历
	while (p != NULL)
	{
		// 打印当前节点的数据
		printf("%d ", p->data);

		// 移动到下一个节点
		// 这是链表遍历的核心：通过next指针逐个访问
		p = p->next;
	}

	// 打印换行，使输出更美观
	printf("\n");
}

/*
 * 功能：获取链表的尾节点（最后一个节点）
 * 参数：L - 链表头节点指针
 * 返回值：返回指向尾节点的指针
 * 说明：从头节点开始，沿着next指针一直走到最后一个节点
 *       尾节点的特征是：它的next为NULL
 */
Node *get_tail(Node *L)
{
	// 从头节点开始
	Node *p = L;

	// 当p->next不为NULL时，说明p还不是最后一个节点
	// 继续向后移动
	while (p->next != NULL)
	{
		// 移动到下一个节点
		p = p->next;
	}

	// 此时p指向尾节点（p->next == NULL）
	return p;
}

/*
 * 功能：尾插法插入节点
 * 参数：tail - 当前尾节点指针
 *      e - 要插入的数据元素
 * 返回值：返回新的尾节点指针（就是刚插入的节点）
 * 说明：在链表末尾添加新节点，新节点成为新的尾节点
 *       使用尾插法需要知道当前尾节点，这就是为什么函数需要tail参数
 */
Node *insertTail(Node *tail, ElemType e)
{
	// 为要插入的新节点分配内存空间
	Node *p = (Node *)malloc(sizeof(Node));

	// 将数据存入新节点的数据域
	p->data = e;

	// 关键步骤1：让原来的尾节点的next指向新节点
	// 这样新节点就被"链"到了链表的末尾
	tail->next = p;

	// 关键步骤2：新节点的next设为NULL，表示它是新的尾节点
	p->next = NULL;

	// 返回新的尾节点指针，方便下次尾插时使用
	return p;
}

/*
 * 功能：在指定位置插入节点
 * 参数：L - 链表头节点指针
 *      pos - 要插入的位置（从1开始计数，1表示第一个数据节点位置）
 *      e - 要插入的数据元素
 * 返回值：成功返回1，失败（位置无效）返回0
 * 说明：在位置pos处插入新节点，原来pos位置的节点会向后移动
 *       注意：需要找到pos位置的前一个节点，才能进行插入操作
 */
int insertNode(Node *L, int pos, ElemType e)
{
	// 从头节点开始
	Node *p = L;
	int i = 0;

	// 找到要插入位置的前一个节点
	// 例如：要在位置2插入，需要找到位置1的节点
	// 循环条件 i < pos-1：需要移动pos-1次才能到达目标位置的前一个节点
	while (i < pos - 1)
	{
		// 移动到下一个节点
		p = p->next;
		i++;

		// 如果p为NULL，说明位置超出了链表长度，插入失败
		if (p == NULL)
		{
			return 0; // 位置无效
		}
	}

	// 此时p指向要插入位置的前一个节点
	// 例如：要在位置2插入，p现在指向位置1的节点

	// 为新节点分配内存空间
	Node *q = (Node *)malloc(sizeof(Node));

	// 将数据存入新节点的数据域
	q->data = e;

	// 关键步骤1：让新节点的next指向原来pos位置的节点
	// 这样新节点就"接上"了原来pos位置及之后的节点
	q->next = p->next;

	// 关键步骤2：让p（前一个节点）的next指向新节点
	// 这样新节点就被插入到了pos位置
	p->next = q;

	return 1; // 插入成功
}

/*
 * 功能：删除指定位置的节点
 * 参数：L - 链表头节点指针
 *      pos - 要删除的位置（从1开始计数，1表示第一个数据节点位置）
 * 返回值：成功返回1，失败（位置无效）返回0
 * 说明：删除pos位置的节点，需要找到pos位置的前一个节点
 *       删除步骤：1. 找到前一个节点p
 *                2. 让p->next指向被删除节点的下一个节点
 *                3. 释放被删除节点的内存
 */
int deleteNode(Node *L, int pos)
{
	// 要删除节点的前驱（前一个节点）
	// 从头节点开始，因为要找到pos位置的前一个节点
	Node *p = L;
	int i = 0;

	// 遍历链表，找到要删除节点的前驱
	// 循环条件 i < pos-1：需要移动pos-1次才能到达目标位置的前一个节点
	while (i < pos - 1)
	{
		// 移动到下一个节点
		p = p->next;
		i++;

		// 如果p为NULL，说明位置超出了链表长度，删除失败
		if (p == NULL)
		{
			return 0; // 位置无效
		}
	}

	// 检查要删除的节点是否存在
	// 如果p->next为NULL，说明pos位置没有节点（位置无效）
	if (p->next == NULL)
	{
		printf("要删除的位置错误\n");
		return 0;
	}

	// q指向要删除的节点（就是p的下一个节点）
	Node *q = p->next;

	// 关键步骤：让要删除节点的前驱指向要删除节点的后继
	// 这样就从链表中"跳过"了要删除的节点
	// 例如：原来是 p -> q -> r，现在变成 p -> r
	p->next = q->next;

	// 释放要删除节点的内存空间
	// 这是非常重要的步骤，避免内存泄漏
	free(q);

	return 1; // 删除成功
}

/*
 * 主函数：演示单链表的各种操作
 */
int main(int argc, char const *argv[])
{
	// 步骤1：初始化一个空链表，list指向头节点
	Node *list = initList();

	// 步骤2：获取当前链表的尾节点（此时链表为空，tail就是头节点）
	Node *tail = get_tail(list);

	// 步骤3：使用尾插法依次插入三个节点，值为10、20、30
	// 注意：每次插入后，tail会更新为新的尾节点
	tail = insertTail(tail, 10); // 链表变为：head -> 10
	tail = insertTail(tail, 20); // 链表变为：head -> 10 -> 20
	tail = insertTail(tail, 30); // 链表变为：head -> 10 -> 20 -> 30

	// 步骤4：遍历并打印链表，应该输出：10 20 30
	printf("初始链表（尾插法插入10, 20, 30）：\n");
	listNode(list);

	// 步骤5：在位置2插入值为15的节点
	// 链表变为：head -> 10 -> 15 -> 20 -> 30
	insertNode(list, 2, 15);

	// 步骤6：遍历并打印链表，应该输出：10 15 20 30
	printf("在位置2插入15后：\n");
	listNode(list);

	// 步骤7：删除位置2的节点（即刚插入的15）
	// 链表变为：head -> 10 -> 20 -> 30
	deleteNode(list, 2);

	// 步骤8：遍历并打印链表，应该输出：10 20 30
	printf("删除位置2的节点后：\n");
	listNode(list);

	return 0; // 程序正常结束
}
